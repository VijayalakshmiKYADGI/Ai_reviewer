"""
GitHubCommenter - Post senior-dev-style inline comments to GitHub PRs

Formats and posts code review comments with severity indicators.
"""

from typing import Dict, Any, List
from tasks.format_comments_task import GitHubReview
from .client import GitHubClient


class GitHubCommenter:
    """Post code review comments to GitHub PRs."""
    
    def __init__(self, client: GitHubClient = None):
        """
        Initialize commenter.
        
        Args:
            client: GitHubClient instance. If None, creates new client.
        """
        self.client = client or GitHubClient()
    
    def _format_comment_body(self, comment: Dict[str, str]) -> str:
        """
        Format comment with severity emoji.
        
        Args:
            comment: Comment dict with 'body' field
            
        Returns:
            Formatted comment with emoji prefix
        """
        body = comment.get("body", "")
        
        # Add severity emoji based on keywords
        if "CRITICAL" in body.upper():
            return f"ðŸ”´ {body}"
        elif "HIGH" in body.upper():
            return f"ðŸŸ¡ {body}"
        elif "MEDIUM" in body.upper():
            return f"ðŸŸ  {body}"
        elif "LOW" in body.upper():
            return f"ðŸŸ¢ {body}"
        else:
            return f"ðŸ’¡ {body}"
    
    def _convert_line_to_position(
        self,
        file_path: str,
        line_number: int,
        pr_files: List[Any]
    ) -> int:
        """
        Convert absolute line number to diff position.
        
        GitHub API requires 'position' in the diff, not absolute line number.
        This is a simplified implementation - production would parse the diff.
        
        Args:
            file_path: Path to file
            line_number: Absolute line number
            pr_files: List of PR file objects
            
        Returns:
            Diff position (for now, returns line_number as approximation)
        """
        # TODO: Implement proper diff position calculation
        # For Phase 8, we'll use line number as position
        # Phase 9 will implement proper diff parsing
        return line_number
    
    async def post_review(
        self,
        repo_full_name: str,
        pr_number: int,
        github_review: GitHubReview
    ) -> str:
        """
        Post a complete code review to GitHub PR.
        
        Args:
            repo_full_name: Full repo name (owner/repo)
            pr_number: PR number
            github_review: GitHubReview object from CrewAI pipeline
            
        Returns:
            Review ID
            
        Example:
            >>> commenter = GitHubCommenter()
            >>> review = GitHubReview(
            ...     inline_comments=[{"path": "app.py", "line": 42, "body": "Fix this"}],
            ...     summary_comment="Great work!",
            ...     review_state="COMMENTED"
            ... )
            >>> review_id = await commenter.post_review("owner/repo", 1, review)
        """
        # Format inline comments for GitHub API
        formatted_comments = []
        
        for comment in github_review.inline_comments:
            # Extract comment data
            path = comment.get("path", "")
            line = int(comment.get("line", 0))
            body = comment.get("body", "")
            
            if not path or not line or not body:
                print(f"Skipping invalid comment: {comment}")
                continue
            
            # Format comment body with emoji
            formatted_body = self._format_comment_body(comment)
            
            # GitHub API format for inline comments
            # Note: Using 'line' for single-line comments (GitHub API v3)
            formatted_comment = {
                "path": path,
                "line": line,
                "body": formatted_body
            }
            
            formatted_comments.append(formatted_comment)
        
        # Map review state to GitHub event
        state_map = {
            "COMMENTED": "COMMENT",
            "APPROVED": "APPROVE",
            "REQUESTED_CHANGES": "REQUEST_CHANGES"
        }
        
        event = state_map.get(github_review.review_state, "COMMENT")
        
        # Format summary comment
        summary = f"""## ðŸ¤– AI Code Review Summary

{github_review.summary_comment}

---
*Generated by AI Code Reviewer*
"""
        
        # Post review via GitHub API
        try:
            review_id = await self.client.create_review(
                repo=repo_full_name,
                pr_number=pr_number,
                body=summary,
                event=event,
                comments=formatted_comments
            )
            
            print(f"âœ… Posted review to {repo_full_name}#{pr_number} (Review ID: {review_id})")
            return review_id
        
        except Exception as e:
            print(f"âŒ Failed to post review: {e}")
            raise
    
    def format_review_preview(self, github_review: GitHubReview) -> str:
        """
        Format review as text preview (for testing without API call).
        
        Args:
            github_review: GitHubReview object
            
        Returns:
            Formatted text preview
        """
        lines = []
        lines.append("=" * 60)
        lines.append("AI CODE REVIEW PREVIEW")
        lines.append("=" * 60)
        lines.append("")
        
        # Summary
        lines.append("SUMMARY:")
        lines.append(github_review.summary_comment)
        lines.append("")
        
        # Review state
        lines.append(f"REVIEW STATE: {github_review.review_state}")
        lines.append("")
        
        # Inline comments
        lines.append(f"INLINE COMMENTS ({len(github_review.inline_comments)}):")
        lines.append("-" * 60)
        
        for i, comment in enumerate(github_review.inline_comments, 1):
            path = comment.get("path", "unknown")
            line = comment.get("line", 0)
            body = comment.get("body", "")
            formatted_body = self._format_comment_body(comment)
            
            lines.append(f"{i}. {path}:L{line}")
            lines.append(f"   {formatted_body}")
            lines.append("")
        
        lines.append("=" * 60)
        
        return "\n".join(lines)
